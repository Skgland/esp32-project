use display_interface::DisplayError;
use display_interface_spi::SPIInterface;
use embedded_graphics::{
    image::{Image, ImageRaw},
    prelude::*,
};
use embedded_graphics_core::pixelcolor::{raw::ToBytes, Rgb565, Rgb888};
use esp_idf_svc::{eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition};
use esp_idf_svc::{hal::gpio::GpioError, timer::EspTaskTimerService};
use esp_idf_svc::{
    hal::task::block_on,
    wifi::{AsyncWifi, AuthMethod, ClientConfiguration, Configuration, EspWifi},
};
use esp_idf_svc::{
    hal::{
        delay::Ets,
        gpio::{AnyIOPin, PinDriver},
        modem::Modem,
        prelude::Peripherals,
        spi::{
            config::{Config, DriverConfig},
            Dma, SpiDeviceDriver, SpiDriver,
        },
    },
    sys::EspError,
};
use std::time::{Duration, Instant};

use mipidsi::{error::InitError, models::ST7789, Builder};

#[allow(unused_imports)]
use esp_idf_svc::sys as _; // If using the `binstart` feature of `esp-idf-sys`, always keep this module imported

#[toml_cfg::toml_config]
pub struct AppConfig {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main() {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = APP_CONFIG;

    if let Err(err) = run(&app_config) {
        log::error!("Got an Error {err}");
    }
}

// the display is in portrait mode so we need images 135 wide by 240 high
static IMAGES: &[(&str, &[u8])] = &[
    ("Qoi Logo", include_bytes!("../images/qoi_logo-135x240.qoi")),
    ("Cube 4", include_bytes!("../images/Qube4-esp32.qoi")),
    ("Honey", include_bytes!("../images/Honey.qoi")),
];

#[derive(Debug, thiserror::Error)]
#[error("{0}")]
enum ProgramError {
    EspError(#[from] EspError),
    Io(#[from] std::io::Error),
    #[error("Failed to decode Image")]
    ImageDecode,
    #[error("{0:?}")]
    GpioInit(InitError<GpioError>),
    #[error("{0:?}")]
    Display(DisplayError),
}

impl From<InitError<GpioError>> for ProgramError {
    fn from(value: InitError<GpioError>) -> Self {
        ProgramError::GpioInit(value)
    }
}
impl From<DisplayError> for ProgramError {
    fn from(value: DisplayError) -> Self {
        ProgramError::Display(value)
    }
}

fn run(config: &AppConfig) -> Result<(), ProgramError> {
    log::info!("Hello, world!");

    let peripherals = Peripherals::take()?;
    let sys_loop = EspSystemEventLoop::take()?;
    let timer_service = EspTaskTimerService::new()?;
    let nvs = EspDefaultNvsPartition::take()?;

    /*
    let _wifi = block_on(connect_wifi(
        peripherals.modem,
        sys_loop,
        timer_service,
        nvs,
        config,
    ))?;
     */

    let mut rst = PinDriver::input_output_od(peripherals.pins.gpio32)?;
    rst.set_pull(esp_idf_svc::hal::gpio::Pull::Up)?;
    let mut dc = PinDriver::input_output_od(peripherals.pins.gpio16)?;
    dc.set_pull(esp_idf_svc::hal::gpio::Pull::Up)?;
    let mut delay = Ets;

    let sclk = peripherals.pins.gpio18;
    let spi = peripherals.spi2;
    let sdo = peripherals.pins.gpio19;

    let spi = SpiDriver::new(
        spi,
        sclk,
        sdo,
        None::<AnyIOPin>,
        &DriverConfig::new().dma(
            Dma::Channel1(240 * 135 * 2 + 8), // 2 bytes per pixel: 5 bit red, 6 bit green, 5 bit blue
                                              // Dma::Channel1(0x1000), // must be multiple of 4 and in 1..=4096 i.e not 0 and <= 0x1000
        ),
    )?;

    let cs = peripherals.pins.gpio5;

    let spi = SpiDeviceDriver::new(spi, Some(cs), &Config::new())?;

    let di = SPIInterface::new(spi, dc);

    let mut display = Builder::new(ST7789, di)
        .display_size(135, 240)
        .display_offset(52, 40)
        .invert_colors(mipidsi::options::ColorInversion::Inverted)
        .reset_pin(rst)
        .init(&mut delay)?;

    display.clear(Rgb565::RED)?;

    let mut bl = PinDriver::input_output_od(peripherals.pins.gpio4)?;
    bl.set_pull(esp_idf_svc::hal::gpio::Pull::Up)?;
    bl.set_high()?;

    static mut IMAGE_BUFFER: [u8; 240 * 135 * 2] = [0u8; 240 * 135 * 2];
    // Safety:
    // - this is the only place a reference to IMAGE_BUFFER is taken
    // - no concurrent calls to run are made
    // - the reference taken does not escape the function
    let image_buffer = unsafe { &mut *core::ptr::addr_of_mut!(IMAGE_BUFFER) };

    let mut next_draw = Instant::now();

    for (image_name, image_data) in IMAGES.iter().cycle() {
        log::debug!("Decoding {image_name} Image Data");

        let Some(raw_image) = decode_qoi_image(image_data, image_buffer) else {
            return Err(ProgramError::ImageDecode);
        };

        let image = Image::new(&raw_image, Point::zero());

        sleep_until(next_draw);

        log::info!("Displaying: {image_name}");

        image.draw(&mut display)?;

        next_draw = Instant::now() + Duration::from_secs(5);
    }

    #[allow(unreachable_code)]
    Ok(())
}

fn sleep_until(target: Instant) {
    let now = Instant::now();
    if now < target {
        log::debug!("Waiting for next image change!");
        std::thread::sleep(target - now);
    }
}

fn decode_qoi_image<'b>(
    qoi_data: &[u8],
    pixel_buffer: &'b mut [u8],
) -> Option<ImageRaw<'b, Rgb565>> {
    let (qoi_header, pixels) = arqoii::decode::QoiDecoder::new(qoi_data.iter().copied())?;

    for (dest_pixel, src_pixel) in pixel_buffer.chunks_exact_mut(2).zip(pixels) {
        let be_pixel =
            Rgb565::from(Rgb888::new(src_pixel.r, src_pixel.g, src_pixel.b)).to_be_bytes();
        dest_pixel[0] = be_pixel[0];
        dest_pixel[1] = be_pixel[1];
    }

    Some(ImageRaw::new(pixel_buffer, qoi_header.width))
}

async fn connect_wifi(
    modem: Modem,
    sys_loop: EspSystemEventLoop,
    timer_service: EspTaskTimerService,
    nvs: EspDefaultNvsPartition,
    config: &AppConfig,
) -> Result<AsyncWifi<EspWifi<'static>>, ProgramError> {
    let mut wifi = AsyncWifi::wrap(
        EspWifi::new(modem, sys_loop.clone(), Some(nvs))?,
        sys_loop,
        timer_service,
    )?;

    let wifi_configuration: Configuration = Configuration::Client(ClientConfiguration {
        ssid: config.wifi_ssid.try_into().unwrap(),
        bssid: None,
        auth_method: AuthMethod::WPA2Personal,
        password: config.wifi_psk.try_into().unwrap(),
        channel: None,
        ..Default::default()
    });

    wifi.set_configuration(&wifi_configuration)?;

    wifi.start().await?;
    log::info!("Wifi started");

    wifi.connect().await?;
    log::info!("Wifi connected");

    wifi.wait_netif_up().await?;
    log::info!("Wifi netif up");

    Ok(wifi)
}
